## **1. map 到底长啥？**

一句话：**map = hmap + 一堆 bmap（桶）**。

-   **hmap** 是头结构体，里边存着元素个数、桶数组指针、旧桶指针、搬迁进度等元数据。
    
        type hmap struct {
            count      int          // 当前元素个数
            flags      uint8        // 状态位（正在扩容、迭代器活跃等）
            B          uint8        // 2^B 是当前桶数组长度
            noverflow  uint16       // 溢出桶近似计数
            hash0      uint32       // 随机哈希种子
            buckets    unsafe.Pointer // 当前桶数组 *[]bmap
            oldbuckets unsafe.Pointer // 旧桶数组 *[]bmap（扩容期间使用）
            nevacuate  uintptr       // 下一个要搬迁的旧桶序号
            ...
        }
    

-   **bmap** 才是真正的桶，源码里只露了 `tophash [8]uint8`，运行时把它后面塞满了：
    
        type bmap struct {
            tophash [bucketCnt]uint8   // bucketCnt == 8，所以 8 个哈希高 8 位
        }
    
    -   运行时真正占用的内存布局，在 `makeBucketArray` 里一次性分配 **一整块**：
        
    
        | 字段            | 字节数 | 说明 |
        |----------------|--------|------|
        | tophash[8]     | 8      | 每个槽位的高 8 位哈希 |
        | keys[8]        | 8*ks   | key 数组，紧密排列 |
        | elems[8]       | 8*vs   | value 数组，紧密排列 |
        | overflow *bmap | 8      | 溢出桶指针（指针槽，可能不存在） |
    
    -   keys/values 的长度分别是 `8×keysize` 和 `8×valuesize`。
        
    -   overflow 字段只在 key 或 value 含指针时存在（由编译期决定，通过 `hmap.flags` 的位记录），否则省掉以节省内存。
        
        如果 key/value 都是“无指针”类型，末尾那个 `overflow` 指针还会被省掉，GC 直接跳过整片内存。
        

* * *

## **2. 怎么根据一个key把它的value捞出来？**

1.  **定位桶**：用哈希值低 B 位 `hash & (2^B-1)` 找到主桶。
    
2.  **判断搬迁**  
    如果发现 `h.oldbuckets != nil`，说明**正在扩容**。此时：
    
    -   先到**新桶链**里查；
        
    -   没找到 → **再去旧桶链**查一遍。
        
3.  **桶内过滤（新/旧桶链通用）**  
    在目标桶链里：
    
    -   用 `tophash[i]` 做 8 路并行过滤；
        
        > 记住：tophash 只是桶内 8 路并行过滤器，**桶外定位全靠低 B 位**。
        
    -   匹配再用 `keys[i]` 全等比对；
        
    -   命中后在对应 `values[i]` 取结果。
        
4.  **命中后顺带搬迁**  
    如果在**旧桶链**里找到了，当前 goroutine 会**立即把这条记录搬（evacuate）到新桶**，再返回结果；下一次再来就直接在新桶命中。
    

> 一句话：先查新桶 → 没找到且正在搬迁 → 再查旧桶 → 命中就顺手搬走。

* * *

## **3. 写入时key和value怎么落位？**

1.  **定位桶**：用哈希值的低 B 位计算桶号 `hash & (2^B-1)`，得到“**新桶链**”里的主桶。
    
2.  **判断搬迁**  
    若发现 `h.oldbuckets != nil`（正在扩容）：
    
    -   **先**把这条旧桶链里所有未搬迁的槽位一次性搬完（`evacuate` 会立即完成当前桶）；
        
    -   搬迁完成后，旧桶链的该桶会被标记为 `evacuatedX/Y`，所有数据已落在新桶链。
        
3.  **落桶插入**  
    数据已确定在新桶链：
    
    -   在当前桶或其溢出桶链里寻找空槽或覆盖同 key 槽；
        
    -   找不到空槽 → 挂新的溢出桶。
        
    -   设置 `tophash[i]`、写入 `keys[i]` 与 `values[i]`；
        
    -   若并发写检测到 `hmap.flags & hashWriting` 已置位，立即 fatal。
        
4.  **触发扩容检查**  
    插入后更新 `count`，并检查是否达到扩容阈值（负载因子 > 6.5 或溢出桶过多），若满足则启动新一轮渐进式搬迁。
    

> 总结：写路径永远只落在新桶；若旧桶还没搬，**先一次性搬完当前桶**，再插入；绝不出现“跨桶写入”或“写旧桶”的情况。

## **4. 扩容 & 渐进式搬迁**

### **4.1 啥时扩？**

-   **增量扩容**：`count > 6.5 * 2^B` → 桶数量翻倍。
    
-   **等量扩容**：溢出桶太多 `noverflow ≥ 2^B` 但负载不高 → 桶数量不变，压缩溢出链。
    

### **4.2 怎么搬？**

Go 搞的是**渐进式搬迁**：

-   只建“新房”，不一次性搬家；
    
-   每次读写操作顺手搬 **2 个旧桶**；
    
-   用 `evacuatedX / evacuatedY` 标记旧桶：
    
    -   `X` → 搬到新前半桶
        
    -   `Y` → 搬到新后半桶
        

> evacuatedX/Y 把“已搬走”这件事直接写进 tophash，省锁又省空间。

## **5. 面试题速查**

### **5.1 内存与 GC**

#### **5.1.1 为什么不能对 map 的 key/value 取地址？**

桶在扩容时会整体搬迁，地址随时变化，运行时只返回值的副本，从根本上杜绝悬空指针。

#### **5.1.2 什么时候会把溢出桶指针省掉？省掉后 GC 如何扫描？**

当 key 和 value 都不含指针时，编译器会把末尾的 `overflow *bmap` 字段省略，整桶变成“无指针块”，GC 扫描阶段直接跳过，减少标记压力。

#### **5.1.3 等量扩容时桶数量不变，为什么还能省内存？**

等量扩容把稀疏的长溢出桶链压缩成紧凑的新桶链，空桶立即归还给 mheap，内存占用下降，但桶数量保持不变。

#### **5.1.4 删除 key 后内存会立即释放吗？**

不会。`delete` 只是把槽位标记为 `emptyOne/emptyRest`，对象本身要等 GC 发现无外部引用才回收；桶本身要等整条链搬迁完成或被整体 GC。

#### **5.1.5 Map 的遍历是有序的还是无序的？**

无序。`for range` 每次都会拍一张快照，桶链的遍历顺序由哈希分布决定，因此同一次程序运行多次遍历顺序都可能不同。

#### **5.1.6 为什么要设计成无序遍历？**

哈希表天然散列无序；防止开发者依赖“隐式顺序”；无序实现简单、性能高，无需额外空间维护插入顺序。

#### **5.1.7 如何让 Map 支持顺序读取？**

标准库 map 本身不支持。常见做法是：

1.  把 key 取出来放到 `[]K` 排序后遍历；
    
2.  使用第三方库或自定义结构体维护插入顺序链表；
    
3.  Go 1.23+ 可用 `iter.Seq` 实现惰性有序遍历。
    

### **5.2 并发与迭代器**

#### **5.2.1 并发读写 panic 的检测位在哪？**

在 `hmap.flags` 第 0 位 `hashWriting`，写路径置位，读路径检测到置位直接 `fatal("concurrent map read and map write")`。

#### **5.2.2** `for range` **迭代时删除或新增元素会发生什么？**

迭代器在初始化时把当时的桶指针、元素计数、哈希种子等做快照，后续增删对可见性无保证：新增可能漏掉，已删仍可能遍历到。

#### **5.2.3 “迭代器快照”机制如何保证不重复、不遗漏？**

搬迁标记 `evacuatedX/Y` + 旧桶指针双保险：遍历旧桶时只扫未搬迁部分，新桶只扫已搬迁部分，已搬迁的旧桶被跳过。

#### **5.2.4** `mapaccess_faststr` **与** `mapaccess1` **的差别？**

当 key 为无指针 string 时，编译器直接调用 `mapaccess_faststr`，走纯汇编实现，比通用版本快约 15–30%。

#### **5.2.5 Map 的 Key 一定要是可比较的吗？为什么？**

必须是可比较类型（支持 `==`）。不可比较类型（slice、map、func 等）在编译期直接报错。原因是哈希表需要靠比较来判断“同一个 key”。

### **5.3. 哈希与冲突**

#### **5.3.1 哈希种子在进程启动时如何生成？fork 后子进程会复用吗？**

启动时读系统熵源（/dev/urandom、getrandom、rdseed 等）生成 64 位种子；fork 不复用熵，子进程直接继承父进程值。

#### **5.3.2 64 位哈希高 8 位也冲突时怎么办？**

tophash 只有 8 位，冲突概率 1/256，冲突后必须再比对 key 全值；但 64 位哈希整体冲突概率极低，tophash 已能过滤绝大多数不匹配槽位。

#### **5.3.3 负载因子阈值为什么是 6.5？**

Google 内部对生产 map 采样得出：6.5 时平均探测链长 ≈ 2.5，cache miss 与扩容次数折中最佳；8 会导致长尾链概率陡增。

#### **5.3.4 溢出桶链表长度超过多少会触发等量扩容？**

当 `noverflow ≥ 2^B` 且当前负载因子 < 6.5 时触发；搬迁策略与增量扩容共用同一套渐进式框架，每次操作搬 2 桶。

### **5.4. 性能陷阱**

#### **5.5.1 为什么** `map[int]struct{}` **比** `map[int]bool]` **省内存？**

bool 实际占 1 字节但对齐到 8 字节，value 数组长度 8×N；struct{} 大小 0，value 数组长度 0，整体内存可省一半以上。

#### **5.5.2 大 value 存指针还是值？**

value > 128 B 时存指针可把 64 B cache line 让给其他数据，减少 cache miss；但多一次指针解引用，需 benchmark 决定。

#### **5.5.3 预分配** `make(map[K]V, hint)` **很大却仍扩容？**

hint 只算主桶，溢出桶按需追加；哈希倾斜时少数桶链过长，等量扩容照样发生。

#### **5.4.4 使用** `json.Unmarshal` **到** `map[string]interface{}` **时为什么仍多次扩容？**

encoding/json 默认 hint=0，字段顺序未知，动态插入平均触发 >6.5/8 的搬迁，时间复杂度退化为 O(N log N)；可预分配 hint 或用流式解码器。

### **5.5. unsafe 边界**

#### **5.5.1 reflect.MapIter 如何保证迭代过程中 map 不会被 GC 回收？**

MapIter 内部用 unsafe.Pointer 持有 hmap，GC 把该指针当根对象，整个桶数组可达，迭代期间 map 不会被回收。

#### **5.5.2 通过 unsafe.Pointer 修改 map 头字段会怎样？**

所有字段无锁保护，改 count 会触发并发检测 fatal；改 B 会导致搬迁越界；改 buckets 指针直接 segfault，官方定义为未定义行为。

#### **5.5.3 如何在不触发写屏障的情况下读取 map？**

读路径无指针写，天然绕过写屏障；运行时 mapaccess 系列函数就是无锁、无屏障的 fast path，保证高并发读性能。

## **6. 补充**

### **6.1. cache line 抖动**

-   **cache line：** CPU 把主存按 **固定大小块**（典型 64 字节）抓到 L1/L2 缓存的最小单位。
    
-   **抖动（thrashing）：** 多个 **不相关变量** 落到同一条 cache line，彼此踢出，导致缓存反复失效、性能暴跌
    
-   解决策略
    
    -   **对齐填充**：把变量隔开到不同 line
        
    -   **集中写**：把频繁写的字段放到独立结构体，远离只读字段。
        
    -   **atomic 或 sharded**：避免多核同时写同 line
